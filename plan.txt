Create a dictionary in python for each word length
2 - 8 for now
Then it will map 'aest' : 'east', 'teas', 'seat', 'taes' etc
This is exactly what I want, as the anagrammer
is just going to look through each word combo 1-7 then look in the dictionary
and print out each of the valid entries.

JUNK CODE:
    def ValidateAndScoreMove(self, plays: list) -> int:
        # A number of things to watch out for here
        # First lets make sure the tile placement is valid
        # all tiles have to be contiguous 
        # all tiles must be in either same row or column
        row = -1
        col = -1
        VERTICAL = 0
        HORIZONTAL = 0
        CONNECTED = False
        minRow = 15
        minCol = 15
        curRow = 15
        curCol = 15
        # Verify all words are in the same row or column
        # And at least one tile is connected to board structure or on center
        for play in plays:
            if play[1] < minRow:
                minRow = play[1]
            if play[1] != curRow:
                VERTICAL += 1
                if HORIZONTAL > 1:
                    self.CleanBoard()
                    print('More than one column used in vertical placement.')
                    return False
            if play[2] < minCol:
                minCol = play[2]
            if play[2] != curCol:
                HORIZONTAL += 1
                if VERTICAL > 1:
                    self.CleanBoard()
                    print('More than one row used in horizontal placement.')
                    return False
            curRow = play[1]
            curCol = play[2]
            if self.PlayBoard[play[1]][play[2]] != '.':
                self.CleanBoard()
                print('Cannot place tile on occupied square.')
                return False
            self.PlayBoard[play[1]][play[2]] = play[0].lower()
            if play[1] == 7 and play[2] == 7:
                CONNECTED = True
            if play[1] != 0:
                adj = self.PlayBoard[play[1]-1][play[2]]
                if adj.isupper():
                    CONNECTED = True
            if play[1] != 14:
                adj = self.PlayBoard[play[1]+1][play[2]]
                if adj.isupper():
                    CONNECTED = True
            if play[2] != 0:
                adj = self.PlayBoard[play[1]][play[2]-1]
                if adj.isupper():
                    CONNECTED = True
            if play[2] != 14:
                adj = self.PlayBoard[play[1]][play[2]+1]
                if adj.isupper():
                    CONNECTED = True  
        if CONNECTED != True:
            self.CleanBoard()
            print('Cannot play disconnected tiles.')
            return False
        # Verify tiles are placed contiguously 
        if len(plays) == 1:
            VERTICAL += 1
        tildeCount = 0
        TotalScore = 0
        if VERTICAL > 1:
            print('vertical placement')
            i = minRow
            wordScore = self.FindWordVertical([i, minCol])
            if wordScore == -1:
                self.CleanBoard()
                return False
            TotalScore += wordScore
            while i != 15 and self.PlayBoard[i][minCol] != '.':
                if self.PlayBoard[i][minCol].islower() or self.PlayBoard[i][minCol] == '?':
                    tildeCount += 1
                    wordScore = self.FindWordHorizontal([i, minCol])
                    if wordScore == -1:
                        self.CleanBoard()
                        return False
                    TotalScore += wordScore
                i += 1

        if HORIZONTAL > 1:
            i = minCol
            wordScore = self.FindWordHorizontal([minRow, i])
            if wordScore == -1:
                self.CleanBoard()
                return False
            TotalScore += wordScore
            while i != 15 and self.PlayBoard[minRow][i] != '.':
                if self.PlayBoard[minRow][i].islower():
                    tildeCount += 1
                    wordScore = self.FindWordVertical([minRow, i])
                    if wordScore == -1:
                        self.CleanBoard()
                        return False
                    TotalScore += wordScore
                i += 1
        if tildeCount != len(plays):
            self.CleanBoard()
            print('Tiles must be played contiguously.')
            return False
        for play in plays:
            self.PlayBoard[play[1]][play[2]] = self.PlayBoard[play[1]][play[2]].upper()
        return TotalScore

            
    #If a letter is lowercase, look underneath and compute multipliers appropriately

    def FindWordHorizontal(self, coord: list) -> int:
        score = 0
        multiplier = 1
        i = coord[1]
        res = ''
        while i != 0 and self.PlayBoard[coord[0]][i-1] != '.':
            i -= 1
        while i != 15 and self.PlayBoard[coord[0]][i] != '.':
            if self.PlayBoard[coord[0]][i].islower():
                multiplier *= self.GetWordMultiplier([coord[0], i])
                #This is broken for blanks
                score += self.GetLetterMultiplier([coord[0], i]) * self.TileScore[self.PlayBoard[coord[0]][i].upper()]
            else:
                score += self.TileScore[self.PlayBoard[coord[0]][i]]
            res += self.PlayBoard[coord[0]][i].upper()
            i += 1
        if len(res) == 1:
            return 0
        if self.CheckWord(res) == False:
            print("Invalid word:",res)
            return -1
        return score * multiplier
    
    def FindWordVertical(self, coord: list) -> int:
        score = 0
        multiplier = 1
        i = coord[0]
        res = ''
        while i != 0 and self.PlayBoard[i-1][coord[1]] != '.':
            i -= 1
        while i != 15 and self.PlayBoard[i][coord[1]] != '.':
            if self.PlayBoard[i][coord[1]].islower():
                multiplier *= self.GetWordMultiplier([i, coord[1]])
                #This is broken for blanks
                score += self.GetLetterMultiplier([i, coord[1]]) * self.TileScore[self.PlayBoard[i][coord[1]].upper()]
            else:
                score += self.TileScore[self.PlayBoard[i][coord[1]]]
            res += self.PlayBoard[i][coord[1]].upper()
            i += 1
        if len(res) == 1:
            return 0
        if self.CheckWord(res) == False:
            print("Invalid word:",res)
            return -1
        return score * multiplier
    
    def GetLetterMultiplier(self, coord: list) -> int:
        square = self.board[coord[0]][coord[1]]
        if square == BoardScore.DOUBLE_LETTER:
            return 2
        elif square == BoardScore.TRIPLE_LETTER:
            return 3
        return 1
    def GetWordMultiplier(self, coord: list) -> int:
        square = self.board[coord[0]][coord[1]]
        if square == BoardScore.DOUBLE_WORD:
            return 2
        elif square == BoardScore.TRIPLE_WORD:
            return 3
        return 1

    def getTiles(self):
        horizontal = []
        vertical = []
        for i in range(15):
            for j in range(15):
                if self.PlayBoard[i][j].isalpha():
                    if (self.inBounds(i-1, j) and not self.PlayBoard[i-1][j].isalpha()) or (self.inBounds(i+1, j) and not self.PlayBoard[i+1][j].isalpha()):
                        horizontal.append([i, j])
                    if (self.inBounds(i, j+1) and not self.PlayBoard[i][j+1].isalpha()) or (self.inBounds(i, j-1) and not self.PlayBoard[i][j-1].isalpha()):
                        vertical.append([i, j])
        return horizontal, vertical
                    
    def inBounds(self, row, col) -> bool:
        if row < 15 and row >= 0 and col < 15 and col >= 0:
            return True
        return False

    def CheckWord(self, w) -> bool:
        if w in self.word_list:
            return True
        return False

So first I want to make and save this file using pickle
Iterate over each word
sort it alphabetically
append the word to the back of the dictionary entry

I may as well have one huge dictionary instead of 7 of variable size
since the hash doesn't make any difference.

Need to figure out blanks

Plan for Scrabble game:
Tilebag class:
* keeps track of how many tiles are left in the bag
* keeps track of which tiles are in the bag
* method to draw a given number of tiles
* method to exchange tiles

Board class:
* Keeps track of board state
* Validates play
    - Are words made in dictionary, is play itself valid

Player class:
* Keeps track of current tiles
* exchange and play methods

Game class:
* keeps track of player scores
* makes sure tile bag is not empty and player rack is not empty


We need to scan the board and find all available letters, and we can put them in a horizontal
and vertical list
so each list will have the square of interest on the board
then for each square of interest, we find a list of words that we can make with
our rack and the letter in the list (this can be done recursively relatively easily using our anagrammer)
then we look over each of these words and see if they will fit on the board.

How do we do this? Given a word and a square on the board, we know we have the letters to make the word,
but we need to make sure it fits on the board.
So we are bounded by the position of the letter on the board, but there may be duplicates.
all we have to do is make sure the play fits inside the bounds of the board. The move function
will take care of the validation.

I should use this trie method
I can build a trie and then save it, but then how to go about implementation?

NEW STRATEGY
suffixes can be done with a tree
prefixes can be done with a reverse tree
and then we just have to make sure that the cross check is valid,
and we are good.

FIRST STEP: MAKE A SUFFIX TREE

//so we have our trie
we have the algorithm for finding the next word given an anchor square
we need the cross table checker
each tile should have a dictionary for letters that can go above,
below
each square points to its neighbor or a nullpointer
when we transpose the board, each neighbor points to the square below insteado
of the square above to the right

//how to do the cross lists
for each square in the anchor list we need to iterate over the whole alphabet and see if it forms a valid word
so we need an anchor list
//but this is kind of complicated 
for each square, we have to make sure that all things are valid
so we go back and bulid above and below trie nodes, and if we find a valid one then we follow it through

How are we going to build the anchor list
in our placement of tiles, we keep track of the tiles we have put down
then if our play is higher scoring than the best one we put the 
why don't I make a play class that contains the score, the locations of the tiles and the tiles used,
and this information is added to the play list.
we can calculate score as we go using the cross tables

each anchor tile on the board tallies up the score along the above and below directions and makes note


we keep track of the multiplier and the total score for the word.
we add precalculated scores to the total score after multiplication.

okkkkkayyyy lets actually do this cross list thing
so for each square in the play that is selected, we go all the way left

TODO:
implement make play
implement game setup and loop logic
TEST TEST TEST functions and their edge cases
print out full move set
pygame should be optional
implement first in ascii text

LONGER TERM
-- visuals with pygame
-- pytorch model













